/**
 * SPDX-License-Identifier: BUSL-1.1
 * Copyright (c) 2025 [Your Company]
 */

/**
 * Citation Validator
 *
 * Validates that citations generated by Answer Agent are:
 * 1. Structurally valid (all required fields present)
 * 2. Semantically valid (spans exist in answer, indices valid)
 * 3. Quality validated (alignment scores meet thresholds)
 *
 * CRITICAL: This prevents hallucinated citations from polluting downstream metrics
 */

import {
  logNoCitations,
  logHallucinatedCitation,
  logLowQualityCitations,
} from "./citation-failure-logger.js";

export interface Citation {
  source: string;
  relevance: number;
  quote: string;
  evidence_idx?: number;
  alignment_score?: number;
  span_in_answer?: string;
}

export interface ValidationResult {
  valid: boolean;
  errors: string[];
  warnings: string[];
  quality_score: number; // 0-1
}

export interface CitationQualityMetrics {
  total_citations: number;
  valid_citations: number;
  invalid_citations: number;
  avg_alignment_score: number;
  citation_coverage: number; // % of answer backed by citations
  has_evidence_idx: number; // % with evidence_idx
  has_alignment_score: number; // % with alignment_score
  has_span: number; // % with span_in_answer
}

/**
 * Validate a single citation
 */
export function validateCitation(
  citation: Citation,
  answerText: string,
  totalEvidenceCount: number,
): ValidationResult {
  const errors: string[] = [];
  const warnings: string[] = [];
  let qualityScore = 1.0;

  // 1. Required fields
  if (!citation.source || citation.source.trim().length === 0) {
    errors.push("Missing or empty 'source' field");
    qualityScore -= 0.3;
  }

  if (typeof citation.relevance !== "number") {
    errors.push("Missing or invalid 'relevance' field");
    qualityScore -= 0.2;
  } else if (citation.relevance < 0 || citation.relevance > 1) {
    warnings.push(
      `Relevance score out of range: ${citation.relevance} (expected 0-1)`,
    );
    qualityScore -= 0.1;
  }

  if (!citation.quote || citation.quote.trim().length === 0) {
    errors.push("Missing or empty 'quote' field");
    qualityScore -= 0.2;
  }

  // 2. Enhanced fields validation
  if (citation.evidence_idx !== undefined) {
    if (typeof citation.evidence_idx !== "number") {
      errors.push("Invalid 'evidence_idx' type (expected number)");
      qualityScore -= 0.1;
    } else if (
      citation.evidence_idx < 0 ||
      citation.evidence_idx >= totalEvidenceCount
    ) {
      errors.push(
        `evidence_idx out of range: ${citation.evidence_idx} (total evidence: ${totalEvidenceCount})`,
      );
      qualityScore -= 0.2;
    }
  } else {
    warnings.push("Missing 'evidence_idx' - citation not traceable");
    qualityScore -= 0.05;
  }

  if (citation.alignment_score !== undefined) {
    if (typeof citation.alignment_score !== "number") {
      errors.push("Invalid 'alignment_score' type (expected number)");
      qualityScore -= 0.1;
    } else if (citation.alignment_score < 0 || citation.alignment_score > 1) {
      errors.push(
        `alignment_score out of range: ${citation.alignment_score} (expected 0-1)`,
      );
      qualityScore -= 0.1;
    } else if (citation.alignment_score < 0.3) {
      warnings.push(
        `Low alignment score: ${citation.alignment_score.toFixed(
          3,
        )} (< 0.3 threshold)`,
      );
      qualityScore -= 0.05;
    }
  } else {
    warnings.push("Missing 'alignment_score' - quality not measured");
    qualityScore -= 0.05;
  }

  // 3. Span validation - CRITICAL for preventing hallucinations
  if (citation.span_in_answer) {
    if (typeof citation.span_in_answer !== "string") {
      errors.push("Invalid 'span_in_answer' type (expected string)");
      qualityScore -= 0.1;
    } else {
      // Check if span actually exists in answer
      const spanExists = answerText.includes(citation.span_in_answer);
      if (!spanExists) {
        // Try partial match (first 50 chars)
        const partialSpan = citation.span_in_answer.substring(0, 50);
        const partialMatch = answerText.includes(partialSpan);

        if (!partialMatch) {
          errors.push(
            `Hallucinated span: "${citation.span_in_answer.substring(
              0,
              50,
            )}..." not found in answer`,
          );
          qualityScore -= 0.3; // Heavy penalty for hallucination
        } else {
          warnings.push("Span partially matches answer (truncated?)");
          qualityScore -= 0.05;
        }
      }
    }
  } else {
    warnings.push("Missing 'span_in_answer' - citation location unknown");
    qualityScore -= 0.05;
  }

  return {
    valid: errors.length === 0,
    errors,
    warnings,
    quality_score: Math.max(0, qualityScore),
  };
}

/**
 * Validate all citations for a QA pair
 */
export function validateCitations(
  citations: Citation[],
  answerText: string,
  evidenceCount: number,
  options?: {
    qaId?: string;
    question?: string;
    enableLogging?: boolean;
  },
): {
  valid: boolean;
  results: ValidationResult[];
  metrics: CitationQualityMetrics;
  overall_quality: number;
} {
  const {
    qaId = "unknown",
    question = "",
    enableLogging = true,
  } = options || {};
  if (!citations || citations.length === 0) {
    // CRITICAL: Empty citations are a FAILURE
    // This enforces the policy that all answers MUST have citations

    // Log the failure
    if (enableLogging) {
      logNoCitations(qaId, question, answerText, evidenceCount);
    }

    return {
      valid: false,
      results: [
        {
          valid: false,
          errors: [
            "POLICY VIOLATION: No citations provided. All answers must include at least 1-2 evidence citations.",
          ],
          warnings: [
            "Answer generated without citing evidence - this violates quality standards",
          ],
          quality_score: 0,
        },
      ],
      metrics: {
        total_citations: 0,
        valid_citations: 0,
        invalid_citations: 1, // Count as 1 invalid to trigger quality gate
        avg_alignment_score: 0,
        citation_coverage: 0,
        has_evidence_idx: 0,
        has_alignment_score: 0,
        has_span: 0,
      },
      overall_quality: 0,
    };
  }

  const results = citations.map((citation) =>
    validateCitation(citation, answerText, evidenceCount),
  );

  // Calculate metrics
  const validCount = results.filter((r) => r.valid).length;
  const invalidCount = results.length - validCount;

  const alignmentScores = citations
    .map((c) => c.alignment_score)
    .filter((s): s is number => s !== undefined);

  const avgAlignmentScore =
    alignmentScores.length > 0
      ? alignmentScores.reduce((sum, s) => sum + s, 0) / alignmentScores.length
      : 0;

  const hasEvidenceIdx = citations.filter(
    (c) => c.evidence_idx !== undefined,
  ).length;
  const hasAlignmentScore = citations.filter(
    (c) => c.alignment_score !== undefined,
  ).length;
  const hasSpan = citations.filter(
    (c) => c.span_in_answer !== undefined,
  ).length;

  // Calculate citation coverage (how much of answer is covered by spans)
  const citedWords = new Set<string>();
  citations.forEach((citation) => {
    if (citation.span_in_answer) {
      const words = citation.span_in_answer
        .toLowerCase()
        .split(/\s+/)
        .filter((w) => w.length > 3);
      words.forEach((w) => citedWords.add(w));
    }
  });

  const answerWords = answerText
    .toLowerCase()
    .split(/\s+/)
    .filter((w) => w.length > 3);

  const citationCoverage =
    answerWords.length > 0 ? citedWords.size / answerWords.length : 0;

  // Overall quality: weighted average
  const qualityScores = results.map((r) => r.quality_score);
  const avgQuality =
    qualityScores.reduce((sum, q) => sum + q, 0) / qualityScores.length;

  const metrics: CitationQualityMetrics = {
    total_citations: citations.length,
    valid_citations: validCount,
    invalid_citations: invalidCount,
    avg_alignment_score: avgAlignmentScore,
    citation_coverage: citationCoverage,
    has_evidence_idx: hasEvidenceIdx / citations.length,
    has_alignment_score: hasAlignmentScore / citations.length,
    has_span: hasSpan / citations.length,
  };

  return {
    valid: invalidCount === 0,
    results,
    metrics,
    overall_quality: avgQuality,
  };
}

/**
 * Batch validation for multiple QA pairs
 */
export function validateQABatch(
  qaItems: Array<{
    qa: { q: string; a: string };
    citations?: Citation[];
    evidence_count?: number;
  }>,
): {
  total_qa: number;
  valid_qa: number;
  invalid_qa: number;
  aggregate_metrics: CitationQualityMetrics;
  per_qa_results: Array<{
    qa_index: number;
    valid: boolean;
    metrics: CitationQualityMetrics;
    errors: string[];
    warnings: string[];
  }>;
} {
  const perQaResults = qaItems.map((item, index) => {
    const citations = item.citations || [];
    const evidenceCount = item.evidence_count || 0;

    const validation = validateCitations(citations, item.qa.a, evidenceCount);

    // Collect all errors and warnings
    const allErrors = validation.results.flatMap((r) => r.errors);
    const allWarnings = validation.results.flatMap((r) => r.warnings);

    return {
      qa_index: index,
      valid: validation.valid,
      metrics: validation.metrics,
      errors: allErrors,
      warnings: allWarnings,
    };
  });

  // Aggregate metrics
  const totalCitations = perQaResults.reduce(
    (sum, r) => sum + r.metrics.total_citations,
    0,
  );
  const validCitations = perQaResults.reduce(
    (sum, r) => sum + r.metrics.valid_citations,
    0,
  );
  const invalidCitations = perQaResults.reduce(
    (sum, r) => sum + r.metrics.invalid_citations,
    0,
  );

  const avgAlignmentScore =
    perQaResults.reduce(
      (sum, r) =>
        sum + r.metrics.avg_alignment_score * r.metrics.total_citations,
      0,
    ) / totalCitations;

  const avgCitationCoverage =
    perQaResults.reduce((sum, r) => sum + r.metrics.citation_coverage, 0) /
    perQaResults.length;

  const aggregateMetrics: CitationQualityMetrics = {
    total_citations: totalCitations,
    valid_citations: validCitations,
    invalid_citations: invalidCitations,
    avg_alignment_score: isNaN(avgAlignmentScore) ? 0 : avgAlignmentScore,
    citation_coverage: avgCitationCoverage,
    has_evidence_idx:
      perQaResults.reduce((sum, r) => sum + r.metrics.has_evidence_idx, 0) /
      perQaResults.length,
    has_alignment_score:
      perQaResults.reduce((sum, r) => sum + r.metrics.has_alignment_score, 0) /
      perQaResults.length,
    has_span:
      perQaResults.reduce((sum, r) => sum + r.metrics.has_span, 0) /
      perQaResults.length,
  };

  return {
    total_qa: qaItems.length,
    valid_qa: perQaResults.filter((r) => r.valid).length,
    invalid_qa: perQaResults.filter((r) => !r.valid).length,
    aggregate_metrics: aggregateMetrics,
    per_qa_results: perQaResults,
  };
}

/**
 * Get quality gate status based on metrics
 */
export function getCitationQualityGate(metrics: CitationQualityMetrics): {
  status: "PASS" | "WARN" | "FAIL";
  reason: string;
} {
  // P0: Critical failures
  if (metrics.total_citations === 0) {
    return { status: "FAIL", reason: "No citations provided" };
  }

  if (metrics.invalid_citations / metrics.total_citations > 0.3) {
    return {
      status: "FAIL",
      reason: `High invalid citation rate: ${(
        (metrics.invalid_citations / metrics.total_citations) *
        100
      ).toFixed(1)}%`,
    };
  }

  // P1: Performance warnings
  if (metrics.avg_alignment_score < 0.4) {
    return {
      status: "WARN",
      reason: `Low average alignment score: ${metrics.avg_alignment_score.toFixed(
        3,
      )}`,
    };
  }

  if (metrics.citation_coverage < 0.5) {
    return {
      status: "WARN",
      reason: `Low citation coverage: ${(
        metrics.citation_coverage * 100
      ).toFixed(1)}%`,
    };
  }

  // P2: Quality issues
  if (metrics.has_evidence_idx < 0.8) {
    return {
      status: "WARN",
      reason: `Missing evidence_idx in ${(
        (1 - metrics.has_evidence_idx) *
        100
      ).toFixed(1)}% of citations`,
    };
  }

  return { status: "PASS", reason: "All citation quality checks passed" };
}
