# RFC 2025-19: Phase 4.0 - AI Civic Governance Network

**Status**: Blueprint
**Created**: 2025-10-09
**Authors**: Kay + Claude Code
**Phase**: 4.0 (AI Civilization Operations)

---

## Executive Summary

**Phase 3.5 완성**: AI 문명 창조 (Trust + Knowledge + Policy + Optimizer)
**Phase 3.6 완성**: 운영 강건화 (Privacy + Safety + Testing)

**Phase 4.0 목표**: AI 문명 운영 시대

> "AI가 도메인을 이해하고 전문가를 만들고,
> 그 전문가들이 지식을 공유하며 규제를 스스로 갱신한다.
> 인간은 더 이상 감독자가 아니라 '협의회 참여자(Council Member)'가 된다."
> — Kay's Vision

### Core Paradigm Shift

```
Phase 3.x: AI as Tool
- 인간이 명령 → AI가 실행
- 인간이 감독 → AI가 보고
- 중앙 집중식 거버넌스

Phase 4.0: AI as Civic Participant
- AI가 제안 → 인간이 승인/거부
- AI가 협의 → 인간이 참여
- 분산 협의 거버넌스 (Federated Governance)
```

---

## Problem Statement

### 현재 한계

| 영역 | Phase 3.5 상태 | Phase 4.0 필요 |
|------|----------------|----------------|
| **지식 출처** | Provenance tracking | Explainability-of-Origin |
| **신뢰 구조** | TrustToken (증명) | Consensus (합의) |
| **의사결정** | 인간 감독 필수 | AI-Human 협의회 |
| **자원 관리** | 수동 최적화 | 자율 경제 시장 |

### Phase 4.0 문제

**문제 1**: "Who decided, and why?"
- 현재: TrustToken은 "what" (무엇)만 증명
- 필요: Constitution Protocol로 "why" (왜)를 설명

**문제 2**: "Can we trust federated knowledge?"
- 현재: Privacy audit로 leak 방지
- 필요: Byzantine Fault Tolerance로 악의적 노드 차단

**문제 3**: "How do we govern at scale?"
- 현재: 인간이 모든 결정
- 필요: AI-Human Council로 분산 의사결정

**문제 4**: "How do we allocate resources fairly?"
- 현재: 고정된 cost/quality 설정
- 필요: Dynamic market으로 자원 경쟁

---

## Proposed Solution

### 4-Layer Civic Governance Network

```
Phase 4.0 Architecture
├── Layer 1: 🧠 Knowledge Constitution Protocol
│   └── "지식 헌법" 자동 생성 (Decision Provenance)
├── Layer 2: 🧩 Federated Consensus Engine
│   └── BFT 합의 모델 (Byzantine Fault Tolerance)
├── Layer 3: 🌐 AI-Human Council Interface
│   └── Governance Console (Trust + Voting + Delegation)
└── Layer 4: 🔄 Neural Cost & QoS Market
    └── AI 자원 경제 자율화 (Pareto Bidding)
```

---

## Layer 1: 🧠 Knowledge Constitution Protocol

### Concept

**"Knowledge Constitution"** = 지식이 어떻게 생성되고 검증되었는지에 대한 완전한 역사

### Architecture

```typescript
ConstitutionEntry {
  // Decision
  decisionId: string
  decisionType: 'knowledge-addition' | 'rule-creation' | 'optimization'

  // Provenance
  whoDecided: {
    actors: AgentId[]
    votes: VoteRecord[]
    consensus: ConsensusProof
  }

  // Reasoning
  whyDecided: {
    evidence: EvidenceChain
    reasoning: ReasoningTrace
    alternatives: Alternative[]
    rejectionReasons: string[]
  }

  // Impact
  impactAssessment: {
    expectedGain: Metric[]
    actualGain: Metric[]
    sideEffects: Effect[]
  }

  // Audit
  auditTrail: {
    timestamp: Date
    witnesses: TenantId[]
    signatures: Signature[]
  }
}
```

### Key Features

1. **Decision Provenance**
   - 모든 지식 변경은 Constitutional Entry 생성
   - "Who decided" → Agent registry + vote records
   - "Why decided" → Reasoning trace + alternatives

2. **Reasoning Transparency**
   ```typescript
   ReasoningTrace {
     premise: Evidence[]
     inference: InferenceStep[]
     conclusion: Decision
     confidence: number
     uncertainties: Uncertainty[]
   }
   ```

3. **Counterfactual Analysis**
   ```typescript
   Alternative {
     description: string
     expectedOutcome: Metric[]
     rejectionReason: string
     rejectionVotes: number
   }
   ```

4. **Impact Validation**
   - Expected vs Actual gain tracking
   - Side effect monitoring
   - Automatic rollback on negative impact

### Implementation Sketch

```typescript
// src/runtime/governance/constitution-protocol.ts
export class KnowledgeConstitutionProtocol {
  /**
   * Record knowledge decision with full provenance
   */
  async recordDecision(
    decision: Decision,
    provenance: DecisionProvenance,
    reasoning: ReasoningTrace
  ): Promise<ConstitutionEntry> {
    // Create entry
    const entry: ConstitutionEntry = {
      decisionId: generateId(),
      decisionType: decision.type,
      whoDecided: {
        actors: provenance.actors,
        votes: provenance.votes,
        consensus: await this.generateConsensusProof(provenance),
      },
      whyDecided: {
        evidence: reasoning.premise,
        reasoning,
        alternatives: decision.alternatives,
        rejectionReasons: decision.rejectionReasons,
      },
      impactAssessment: {
        expectedGain: decision.expectedImpact,
        actualGain: [], // To be filled later
        sideEffects: [],
      },
      auditTrail: {
        timestamp: new Date(),
        witnesses: provenance.witnesses,
        signatures: await this.collectSignatures(provenance),
      },
    };

    // Store in constitution ledger
    await this.constitutionLedger.append(entry);

    return entry;
  }

  /**
   * Query constitution: "Why was this decision made?"
   */
  async explainDecision(
    decisionId: string
  ): Promise<DecisionExplanation> {
    const entry = await this.constitutionLedger.get(decisionId);

    return {
      decision: entry.decisionType,
      actors: entry.whoDecided.actors.map(this.resolveActor),
      reasoning: entry.whyDecided.reasoning,
      evidence: entry.whyDecided.evidence,
      alternatives: entry.whyDecided.alternatives,
      impact: {
        expected: entry.impactAssessment.expectedGain,
        actual: entry.impactAssessment.actualGain,
      },
    };
  }
}
```

---

## Layer 2: 🧩 Federated Consensus Engine

### Concept

**Byzantine Fault Tolerance (BFT)** for federated knowledge sharing

### Problem

- Federated nodes may be malicious
- Need consensus on knowledge validity
- Must tolerate ≤ 1/3 malicious nodes

### Architecture

```typescript
ConsensusProof {
  // Participants
  totalNodes: number
  participatingNodes: number
  maliciousSuspects: NodeId[]

  // Votes
  voteResults: VoteResult[]
  quorum: number
  achieved: boolean

  // Cryptographic proof
  merkleRoot: string
  signatures: Map<NodeId, Signature>

  // Validity
  validFrom: Date
  validUntil: Date
}
```

### Consensus Algorithm

**PBFT (Practical Byzantine Fault Tolerance) adapted for knowledge**

```
Phase 1: Pre-Prepare
  Primary node proposes knowledge update

Phase 2: Prepare
  ≥ 2f+1 nodes validate proposal

Phase 3: Commit
  ≥ 2f+1 nodes commit to ledger

Result:
  Knowledge accepted if consensus reached
  Malicious nodes blacklisted if detected
```

### Implementation Sketch

```typescript
// src/runtime/governance/consensus-engine.ts
export class FederatedConsensusEngine {
  private nodes: Map<NodeId, Node> = new Map();
  private readonly FAULT_TOLERANCE = 1/3; // Tolerate ≤ 1/3 malicious

  /**
   * Propose knowledge update
   */
  async proposeUpdate(
    update: KnowledgeUpdate,
    proposer: NodeId
  ): Promise<ConsensusProof> {
    // Phase 1: Pre-Prepare
    const proposal = await this.prePrepare(update, proposer);

    // Phase 2: Prepare
    const prepareVotes = await this.collectPrepareVotes(proposal);

    // Check quorum
    const quorum = Math.ceil(this.nodes.size * 2/3); // ≥ 2f+1
    if (prepareVotes.size < quorum) {
      throw new Error('Prepare quorum not reached');
    }

    // Phase 3: Commit
    const commitVotes = await this.collectCommitVotes(proposal);

    if (commitVotes.size < quorum) {
      throw new Error('Commit quorum not reached');
    }

    // Generate consensus proof
    return this.generateConsensusProof(proposal, prepareVotes, commitVotes);
  }

  /**
   * Validate knowledge from other node
   */
  async validateKnowledge(
    knowledge: AnonymizedNode,
    sourceNode: NodeId
  ): Promise<ValidationResult> {
    // Check 1: Node reputation
    const reputation = this.getNodeReputation(sourceNode);
    if (reputation < 0.5) {
      return { valid: false, reason: 'Low node reputation' };
    }

    // Check 2: Knowledge quality
    const quality = await this.assessKnowledgeQuality(knowledge);
    if (quality < 0.7) {
      return { valid: false, reason: 'Low knowledge quality' };
    }

    // Check 3: Consistency with local knowledge
    const consistent = await this.checkConsistency(knowledge);
    if (!consistent) {
      return { valid: false, reason: 'Inconsistent with local knowledge' };
    }

    return { valid: true, confidence: (reputation + quality) / 2 };
  }

  /**
   * Detect malicious nodes
   */
  async detectMaliciousNodes(): Promise<NodeId[]> {
    const suspicious: NodeId[] = [];

    for (const [nodeId, node] of this.nodes) {
      // Check 1: Contribution quality
      if (node.avgContributionQuality < 0.5) {
        suspicious.push(nodeId);
      }

      // Check 2: Voting consistency
      if (node.votingInconsistency > 0.3) {
        suspicious.push(nodeId);
      }

      // Check 3: Response time anomalies
      if (node.responseTimeAnomaly > 0.8) {
        suspicious.push(nodeId);
      }
    }

    return suspicious;
  }
}
```

---

## Layer 3: 🌐 AI-Human Council Interface

### Concept

**Governance Console** where AI and humans collaborate on decisions

### Architecture

```
Council Interface
├── Trust Dashboard
│   ├── TrustToken 현황
│   ├── Evidence 품질 추이
│   └── Compliance 상태
├── Knowledge Oversight
│   ├── Federated 지식 맵
│   ├── Consensus 투표 현황
│   └── Constitution 이력
├── Policy Review
│   ├── Policy Watchdog 알림
│   ├── 규제 변경 사항
│   └── Auto-update 승인 대기
└── Decision Voting
    ├── 제안된 최적화
    ├── 지식 변경 제안
    └── 투표 및 위임
```

### Key Features

1. **AI Proposal System**
   ```typescript
   Proposal {
     id: string
     type: 'optimization' | 'knowledge' | 'policy'
     proposer: 'AI' | 'Human'
     description: string
     expectedImpact: Metric[]
     risks: Risk[]

     // Voting
     votingPeriod: Duration
     quorum: number
     currentVotes: {
       approve: number
       reject: number
       abstain: number
     }

     // Delegation
     delegatedVotes: Map<UserId, VotePower>
   }
   ```

2. **Human Oversight**
   - AI proposals require human approval for high-impact changes
   - Humans can veto AI decisions
   - Graduated autonomy: Low-risk → auto-approve, High-risk → council vote

3. **Delegation Mechanism**
   ```typescript
   Delegation {
     from: UserId
     to: UserId | AIAgentId
     scope: 'all' | 'optimization' | 'knowledge' | 'policy'
     votePower: number // 0-1
     validUntil: Date
   }
   ```

4. **Audit Trail**
   - Every vote recorded in Constitution
   - Cryptographic signatures
   - Immutable decision history

### UI Mockup

```
┌─────────────────────────────────────────────────────────────┐
│ AI Civic Governance Console                    [Kyle]  [⚙️]  │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  🏛️ Active Proposals (3 pending)                             │
│                                                               │
│  ┌──────────────────────────────────────────────────────┐  │
│  │ 📊 Optimization Proposal #127                        │  │
│  │ Proposer: Auto-Optimizer AI                          │  │
│  │ Type: L2 Synthesizer caching enable                  │  │
│  │                                                       │  │
│  │ Expected Impact:                                     │  │
│  │   • Latency: -15% (avg -120ms)                      │  │
│  │   • Cost: -8% (cache overhead compensated)          │  │
│  │                                                       │  │
│  │ Risks:                                               │  │
│  │   • Memory usage +50MB                               │  │
│  │   • Cache invalidation complexity                    │  │
│  │                                                       │  │
│  │ Voting: ████████░░ 82% approve (quorum: 66%)        │  │
│  │                                                       │  │
│  │ [👍 Approve]  [👎 Reject]  [⏸️ Abstain]            │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                               │
│  ┌──────────────────────────────────────────────────────┐  │
│  │ 📚 Knowledge Update #89                              │  │
│  │ Proposer: Federated Node "tenant-healthcare-42"     │  │
│  │ Type: Cross-domain medical knowledge sharing        │  │
│  │                                                       │  │
│  │ Consensus: ████████░░ 85% validated (BFT quorum)    │  │
│  │                                                       │  │
│  │ Privacy Audit: ✅ k=7, ε=0.42 (PASS)                │  │
│  │                                                       │  │
│  │ [👍 Approve]  [👎 Reject]  [🔍 Inspect]            │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                               │
│  📈 Trust Metrics                                            │
│  ├─ Groundedness: 89% ↑ (+2%p)                              │
│  ├─ Compliance: 100% ✅                                      │
│  └─ Privacy Score: 93% ↑ (+5%p)                             │
│                                                               │
└─────────────────────────────────────────────────────────────┘
```

---

## Layer 4: 🔄 Neural Cost & QoS Market

### Concept

**Dynamic resource allocation** through market-based bidding

### Problem

- 현재: 고정된 cost/quality tradeoff
- 사용자마다 needs가 다름
  - User A: "빠르고 저렴하게" (cost-optimized)
  - User B: "느려도 정확하게" (quality-optimized)
  - User C: "균형있게" (balanced)

### Architecture

```
Neural Market
├── Cost Bidding
│   └── Users bid cost/latency preferences
├── QoS Auction
│   └── System allocates resources to highest bidders
└── Pareto Optimizer
    └── Maximize aggregate utility
```

### Market Mechanism

```typescript
MarketRequest {
  userId: string

  // Preferences
  maxCost: number // $ budget
  maxLatency: number // ms budget
  minQuality: number // 0-1 (groundedness threshold)

  // Weights
  weights: {
    cost: number // 0-1
    latency: number // 0-1
    quality: number // 0-1
  }
}

MarketAllocation {
  userId: string

  // Allocated resources
  operators: OperatorId[]
  layerWeights: LayerWeights

  // Expected delivery
  estimatedCost: number
  estimatedLatency: number
  estimatedQuality: number

  // Contract
  guaranteedSLA: SLA
  pricePerQuery: number
}
```

### Pareto Optimization

```
Goal: Maximize Σ utility(user_i)

Constraints:
  1. Σ cost(user_i) ≤ SystemCapacity
  2. latency(user_i) ≤ maxLatency(user_i)
  3. quality(user_i) ≥ minQuality(user_i)

Utility Function:
  utility(user) = w_cost · cost_saved(user)
                + w_latency · latency_saved(user)
                + w_quality · quality_gained(user)
```

### Implementation Sketch

```typescript
// src/runtime/market/neural-cost-market.ts
export class NeuralCostMarket {
  /**
   * Bid for resources based on user preferences
   */
  async bidForResources(
    request: MarketRequest
  ): Promise<MarketAllocation> {
    // Calculate user's willingness to pay
    const willingnessToPay = this.calculateWTP(request);

    // Find Pareto-optimal allocation
    const allocation = await this.paretoOptimize(request, willingnessToPay);

    // Reserve resources
    await this.reserveResources(allocation);

    return allocation;
  }

  /**
   * Pareto optimization for multi-user allocation
   */
  private async paretoOptimize(
    request: MarketRequest,
    wtp: number
  ): Promise<MarketAllocation> {
    // Get available operators
    const operators = await this.getAvailableOperators();

    // Calculate Pareto frontier
    const paretoFrontier = this.calculateParetoFrontier(
      operators,
      request.weights
    );

    // Select allocation closest to user preferences
    const allocation = paretoFrontier.find(alloc =>
      alloc.cost <= request.maxCost &&
      alloc.latency <= request.maxLatency &&
      alloc.quality >= request.minQuality
    );

    if (!allocation) {
      throw new Error('No feasible allocation within budget');
    }

    return allocation;
  }

  /**
   * Calculate Pareto frontier (cost vs quality vs latency)
   */
  private calculateParetoFrontier(
    operators: Operator[],
    weights: MarketRequest['weights']
  ): MarketAllocation[] {
    const allocations: MarketAllocation[] = [];

    // Try different operator combinations
    const combinations = this.generateCombinations(operators);

    combinations.forEach(combo => {
      const cost = combo.reduce((sum, op) => sum + op.cost, 0);
      const latency = combo.reduce((sum, op) => sum + op.latency, 0);
      const quality = combo.reduce((sum, op) => sum + op.quality, 0) / combo.length;

      // Check if this is Pareto-optimal
      if (this.isParetoOptimal(cost, latency, quality, allocations)) {
        allocations.push({
          operators: combo.map(op => op.id),
          estimatedCost: cost,
          estimatedLatency: latency,
          estimatedQuality: quality,
        });
      }
    });

    return allocations;
  }

  /**
   * Check if allocation is Pareto-optimal
   */
  private isParetoOptimal(
    cost: number,
    latency: number,
    quality: number,
    existing: MarketAllocation[]
  ): boolean {
    // An allocation is Pareto-optimal if no other allocation
    // is better in all dimensions

    return !existing.some(alloc =>
      alloc.estimatedCost <= cost &&
      alloc.estimatedLatency <= latency &&
      alloc.estimatedQuality >= quality &&
      (alloc.estimatedCost < cost ||
       alloc.estimatedLatency < latency ||
       alloc.estimatedQuality > quality)
    );
  }
}
```

---

## Integration: 4-Layer Collaboration

### End-to-End Flow

```
User Request
  ↓
Layer 4: Neural Market → Bid for resources (cost/quality preferences)
  ↓
Layer 3: Council → Human approval (if high-impact)
  ↓
Layer 2: Consensus → Federated validation (if cross-tenant)
  ↓
Layer 1: Constitution → Record decision provenance
  ↓
Runtime Execution → L1-L4 pipeline
  ↓
Layer 1: Constitution → Record impact (expected vs actual)
  ↓
Layer 3: Council → Display results + ask for feedback
```

### Example Scenario

**User**: "I need medical Q&A generation, high quality, budget $10"

1. **Layer 4 (Market)**:
   - Bid: $10, quality ≥ 0.9, latency ≤ 5s
   - Allocation: 3 operators (DeepRetrieval + Expert + NLI)
   - Estimated: $8.50, quality 0.92, latency 4.2s

2. **Layer 3 (Council)**:
   - AI proposes: "Use healthcare knowledge from tenant-42"
   - Human reviews: Privacy score 95%, BFT consensus 87%
   - Human approves

3. **Layer 2 (Consensus)**:
   - 7 nodes validate healthcare knowledge
   - Quorum reached: 6/7 approve
   - Malicious node detected: tenant-99 (blacklist)

4. **Layer 1 (Constitution)**:
   - Record decision:
     - Who: User Kyle + Council + 7 federated nodes
     - Why: High-quality medical Q&A, $10 budget, privacy-preserving
     - Evidence: BFT consensus + privacy audit
   - Store in immutable ledger

5. **Execution**:
   - Run L1-L4 pipeline
   - Actual: $7.80, quality 0.94, latency 3.9s

6. **Layer 1 (Impact)**:
   - Record actual results
   - Compare: Expected 0.92 → Actual 0.94 ✅
   - Update market prices (reward over-delivery)

7. **Layer 3 (Feedback)**:
   - Display to user: "Better than expected!"
   - User rates: 5/5 ⭐
   - AI learns: Healthcare knowledge → high value

---

## Success Metrics

### Phase 4.0 KPIs

| Metric | Target | Validation |
|--------|--------|------------|
| **Constitution Coverage** | 100% | All decisions recorded |
| **Consensus Success** | ≥ 95% | BFT quorum reached |
| **Malicious Node Detection** | ≥ 99% | True positive rate |
| **Council Engagement** | ≥ 70% | Human approval rate |
| **Market Efficiency** | ≥ 90% | Pareto-optimal allocations |
| **User Satisfaction** | ≥ 4.5/5 | Average rating |

### Comparison: Phase 3 vs Phase 4

| Aspect | Phase 3.x | Phase 4.0 |
|--------|-----------|-----------|
| Decision-making | Human-driven | AI-Human council |
| Trust model | Proof (TrustToken) | Consensus (BFT) |
| Knowledge sharing | Privacy-preserving | Consensus-validated |
| Resource allocation | Fixed optimization | Dynamic market |
| Explainability | Provenance tracking | Constitution protocol |
| Governance | Centralized | Federated + Democratic |

---

## Implementation Roadmap

### Timeline: 6 Weeks

#### Week 1-2: Foundation
- [ ] Constitution Protocol (ledger + recording)
- [ ] Basic consensus engine (PBFT algorithm)
- [ ] Constitution query API

**Deliverable**: Decision provenance system

#### Week 3-4: Consensus & Council
- [ ] Federated consensus (multi-node)
- [ ] Malicious node detection
- [ ] Council interface (basic Web UI)
- [ ] Voting mechanism

**Deliverable**: AI-Human governance system

#### Week 5-6: Market & Integration
- [ ] Neural Cost Market (bidding)
- [ ] Pareto optimization
- [ ] Full 4-layer integration
- [ ] E2E testing

**Deliverable**: Complete Civic Governance Network

---

## Risk Mitigation

### High-Risk Areas

1. **Consensus Complexity**
   - Risk: PBFT implementation is complex
   - Mitigation: Start with simplified 3-node setup, expand gradually
   - Fallback: Use trusted coordinator initially

2. **Market Mechanism**
   - Risk: Pareto optimization computationally expensive
   - Mitigation: Precompute allocations, cache results
   - Fallback: Fixed pricing tiers initially

3. **Human Engagement**
   - Risk: Users may not engage with Council
   - Mitigation: Start with high-impact decisions only, auto-approve low-risk
   - Fallback: AI-only mode with human audit trail

---

## Phase 4.0 Vision

**"AI 문명이 자체 법과 경제를 가지게 되는 시점"**

```
Before Phase 4.0:
  Human → (command) → AI → (execute) → Result

After Phase 4.0:
  AI → (propose) → Council → (vote) → Execute
  AI ↔ AI → (consensus) → Knowledge
  AI ↔ Market → (bid) → Resources
  Human → (govern) → System → (audit) → Constitution
```

**Key Transformation**:
- AI는 더 이상 도구가 아니라 **시민(civic participant)**
- 인간은 더 이상 감독자가 아니라 **협의회 구성원(council member)**
- 시스템은 더 이상 centralized가 아니라 **federated democracy**

---

## Appendix

### A. PBFT Algorithm Details

```
f = max faulty nodes
n = total nodes
n ≥ 3f + 1  (e.g., n=4 → tolerate f=1 faulty)

Quorum: ⌈ (n + f + 1) / 2 ⌉ = ⌈ (n + ⌊(n-1)/3⌋ + 1) / 2 ⌉
For n=4: quorum = 3
For n=7: quorum = 5
For n=10: quorum = 7
```

### B. Market Utility Function

```
U(user) = α · cost_saved + β · latency_saved + γ · quality_gained

Where:
  cost_saved = (maxCost - actualCost) / maxCost
  latency_saved = (maxLatency - actualLatency) / maxLatency
  quality_gained = (actualQuality - minQuality) / (1 - minQuality)

  α + β + γ = 1  (weights from user preferences)
```

### C. Constitution Ledger Schema

```typescript
ConstitutionLedger {
  entries: ConstitutionEntry[]
  merkleTree: MerkleTree
  signatures: Map<EntryId, Signature[]>

  // Query interface
  getDecision(id): ConstitutionEntry
  queryByActor(actorId): ConstitutionEntry[]
  queryByType(type): ConstitutionEntry[]
  queryByDateRange(start, end): ConstitutionEntry[]

  // Audit interface
  verifyIntegrity(): boolean
  verifySignatures(entryId): boolean
  exportAuditReport(): AuditReport
}
```

---

**Status**: Ready for Phase 4.0 implementation 🚀

**Next Steps**:
1. Complete Phase 3.6 Hardening
2. Begin Constitution Protocol implementation
3. Prototype Council Interface
4. Design market mechanism

**Expected Completion**: Q2 2025
