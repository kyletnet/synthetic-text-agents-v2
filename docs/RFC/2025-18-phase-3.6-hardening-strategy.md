# RFC 2025-18: Phase 3.6 Hardening Strategy

**Status**: Active
**Created**: 2025-10-09
**Authors**: Kay + Claude Code
**Phase**: 3.6 (Operational Hardening)

---

## Executive Summary

Phase 3.5는 AI 문명의 코어 프로토콜을 완성했다:
- ✅ Trust Infrastructure (TrustToken + Evidence + Snapshot)
- ✅ Federated Knowledge Fabric (cross-domain learning +50%)
- ✅ Policy Watchdog v2 (규제 자동 추적)
- ✅ Auto-Optimizer (성능 자동 최적화)

**그러나**, 운영 강건성이 부족하다:
- ⚠️ Integration Tests: 71개 (목표 400+)
- ⚠️ Federated Privacy: k-anonymity/ε-DP 검증 없음
- ⚠️ Optimizer Safety: rollback/cooldown 정책 없음

**Phase 3.6 목표**: 배포 리스크 0 보장, 100% 신뢰 운영

---

## Problem Statement

### 현재 리스크

| 영역 | 문제 | 영향 | 심각도 |
|------|------|------|--------|
| **Testing** | Integration tests 부족 (71/400) | 배포 시 regression 가능 | P0 |
| **Privacy** | k-anonymity/ε-DP 검증 없음 | Cross-tenant data leak 가능 | P1 |
| **Optimizer** | Safety controller 없음 | 과적응/성능 저하 가능 | P1 |
| **Chaos** | Chaos simulation 없음 | 장애 대응 능력 미검증 | P2 |

### 목표 KPI

| 지표 | 현재 | 목표 | Gap |
|------|------|------|-----|
| Integration Tests | 71 | 400+ | +329 |
| Test Coverage | ~60% | 85%+ | +25%p |
| Privacy Score | 88% | 95%+ | +7%p |
| Optimizer Stability | 98% | 99%+ | +1%p |
| Chaos Resilience | 0% | 90%+ | +90%p |

---

## Proposed Solution

### 3축 전략: Validation + Privacy + Optimizer

```
Phase 3.6 Hardening
├── Axis 1: 🧱 Validation Hardening
│   ├── Integration Tests 400+
│   ├── Regression Gate 자동화
│   └── Chaos Simulation 4종
├── Axis 2: 🔐 Federated Privacy Audit
│   ├── k-anonymity 검증 (k ≥ 5)
│   ├── ε-Differential Privacy
│   └── Cross-tenant leak detection
└── Axis 3: ⚡ Optimizer Safety Controller
    ├── Auto-rollback (Δlatency > 10%)
    ├── Bandit cooldown (24h)
    └── Risk level monitoring
```

---

## Axis 1: 🧱 Validation Hardening

### 1.1 Integration Tests 400+ 전략

**현재 상태**: 71개 테스트 파일

**목표**: 400+ 통합 테스트 + Gate 자동화

#### Test Taxonomy

```typescript
tests/
├── integration/                        (NEW - 400+ tests)
│   ├── runtime/                       (100 tests)
│   │   ├── l1-retrieval.test.ts       (25)
│   │   ├── l2-synthesizer.test.ts     (25)
│   │   ├── l3-planner.test.ts         (25)
│   │   └── l4-orchestrator.test.ts    (25)
│   ├── trust/                         (80 tests)
│   │   ├── trust-token.test.ts        (20)
│   │   ├── evidence-store.test.ts     (20)
│   │   ├── snapshot-logger.test.ts    (20)
│   │   └── provenance-tracker.test.ts (20)
│   ├── knowledge/                     (60 tests)
│   │   ├── knowledge-fabric.test.ts   (30)
│   │   └── graph-builder.test.ts      (30)
│   ├── policy/                        (60 tests)
│   │   ├── policy-watchdog.test.ts    (30)
│   │   └── gcg-integration.test.ts    (30)
│   ├── optimizer/                     (60 tests)
│   │   ├── auto-optimizer.test.ts     (30)
│   │   └── profiler.test.ts           (30)
│   └── e2e/                           (40 tests)
│       ├── full-pipeline.test.ts      (20)
│       └── cross-system.test.ts       (20)
├── regression/                        (NEW)
│   └── gates/
│       ├── gate-a-o.test.ts           (15 gates)
│       ├── gate-r.test.ts             (Robustness)
│       ├── gate-e.test.ts             (Explainability)
│       └── gate-v.test.ts             (Value)
└── chaos/                             (NEW)
    ├── timeout-chaos.test.ts
    ├── router-chaos.test.ts
    ├── corpus-chaos.test.ts
    └── policy-chaos.test.ts
```

#### Test Implementation Strategy

**Phase 1 (Week 1)**: Foundation
- [x] Runtime Layer Tests (100)
- [x] Trust Infrastructure Tests (80)
- Total: 180 tests

**Phase 2 (Week 2)**: Integration
- [ ] Knowledge Fabric Tests (60)
- [ ] Policy Watchdog Tests (60)
- [ ] Optimizer Tests (60)
- Total: 180 tests

**Phase 3 (Week 3)**: E2E + Chaos
- [ ] E2E Pipeline Tests (40)
- [ ] Regression Gates (15)
- [ ] Chaos Simulation (4)
- Total: 59 tests

**Total**: 419 tests (목표 초과 달성)

### 1.2 Regression Gate 자동화

```typescript
// scripts/ci/regression-gate-runner.ts
export class RegressionGateRunner {
  async runAllGates(): Promise<GateResults> {
    const gates = [
      'A-Accuracy', 'B-Behavior', 'C-Cost', 'D-Diversity',
      'E-Explainability', 'F-Faithfulness', 'G-Groundedness',
      'H-Hallucination', 'I-Intent', 'J-Justice', 'K-Knowledge',
      'L-Latency', 'M-Memory', 'N-NLI', 'O-Optimization',
      'R-Robustness', 'V-Value'
    ];

    const results = await Promise.all(
      gates.map(gate => this.runGate(gate))
    );

    return this.aggregateResults(results);
  }

  private async runGate(gate: string): Promise<GateResult> {
    // Load baseline metrics
    const baseline = await this.loadBaseline(gate);

    // Run current tests
    const current = await this.runTests(gate);

    // Compare
    return this.compare(baseline, current);
  }
}
```

### 1.3 Chaos Simulation 4종

#### Timeout Chaos
```typescript
// tests/chaos/timeout-chaos.test.ts
describe('Timeout Chaos Engineering', () => {
  it('should handle L1 retrieval timeout gracefully', async () => {
    const chaos = new TimeoutChaos({ layer: 'L1', timeout: 100 });
    const result = await runWithChaos(chaos);
    expect(result.degraded).toBe(true);
    expect(result.fallbackUsed).toBe(true);
  });

  it('should cascade timeout detection', async () => {
    // L1 timeout → L2 detects → L3 adjusts → L4 degrades gracefully
  });
});
```

#### Router Chaos
```typescript
// tests/chaos/router-chaos.test.ts
describe('Router Chaos Engineering', () => {
  it('should handle operator routing failure', async () => {
    const chaos = new RouterChaos({ failureRate: 0.3 });
    // Inject 30% routing failures
    // Expect: Fallback routing + degradation alerts
  });
});
```

#### Corpus Chaos
```typescript
// tests/chaos/corpus-chaos.test.ts
describe('Corpus Chaos Engineering', () => {
  it('should handle missing corpus chunks', async () => {
    const chaos = new CorpusChaos({ missingChunks: 0.2 });
    // Inject 20% missing chunks
    // Expect: Partial retrieval + quality degradation
  });
});
```

#### Policy Chaos
```typescript
// tests/chaos/policy-chaos.test.ts
describe('Policy Chaos Engineering', () => {
  it('should handle conflicting policy rules', async () => {
    const chaos = new PolicyChaos({ conflictRate: 0.1 });
    // Inject 10% conflicting rules
    // Expect: Conflict resolution + compliance maintained
  });
});
```

---

## Axis 2: 🔐 Federated Privacy Audit

### 2.1 k-Anonymity 검증

**목표**: k ≥ 5 (minimum group size)

```typescript
// src/runtime/federated/privacy-audit.ts
export class FederatedPrivacyAuditor {
  /**
   * Verify k-anonymity for shared knowledge
   */
  async verifyKAnonymity(
    fabric: KnowledgeFabric,
    k: number = 5
  ): Promise<KAnonymityResult> {
    const violations: Violation[] = [];

    // Group nodes by quasi-identifiers
    const groups = this.groupByQuasiIdentifiers(fabric.nodes);

    // Check each group size
    for (const [identifier, nodes] of groups) {
      if (nodes.length < k) {
        violations.push({
          identifier,
          groupSize: nodes.length,
          minRequired: k,
          severity: 'high',
          recommendation: 'Suppress or generalize quasi-identifiers'
        });
      }
    }

    return {
      passed: violations.length === 0,
      k,
      totalGroups: groups.size,
      violations,
      privacyScore: this.calculatePrivacyScore(groups, k)
    };
  }

  /**
   * Group nodes by quasi-identifiers
   */
  private groupByQuasiIdentifiers(
    nodes: AnonymizedNode[]
  ): Map<string, AnonymizedNode[]> {
    const groups = new Map<string, AnonymizedNode[]>();

    nodes.forEach(node => {
      // Quasi-identifier: domain + conceptType + importance range
      const qi = this.computeQuasiIdentifier(node);

      if (!groups.has(qi)) {
        groups.set(qi, []);
      }
      groups.get(qi)!.push(node);
    });

    return groups;
  }

  private computeQuasiIdentifier(node: AnonymizedNode): string {
    const importanceRange = Math.floor(node.importance * 10) / 10;
    return `${node.domain}:${node.conceptType}:${importanceRange}`;
  }
}
```

### 2.2 ε-Differential Privacy 검증

**목표**: ε ≤ 1.0 (privacy budget)

```typescript
export class DifferentialPrivacyAuditor {
  /**
   * Verify differential privacy guarantee
   */
  async verifyDifferentialPrivacy(
    fabric: KnowledgeFabric,
    epsilon: number = 1.0
  ): Promise<DPResult> {
    // Sensitivity analysis
    const sensitivity = this.computeSensitivity(fabric);

    // Privacy budget tracking
    const budget = this.trackPrivacyBudget(fabric);

    // Noise validation
    const noiseValidation = this.validateNoise(fabric, epsilon, sensitivity);

    return {
      passed: budget.total <= epsilon && noiseValidation.adequate,
      epsilon,
      sensitivity,
      budget,
      noiseValidation,
      recommendation: this.generateRecommendation(budget, epsilon)
    };
  }

  private computeSensitivity(fabric: KnowledgeFabric): number {
    // Global sensitivity = max change in output from single record
    // For knowledge graphs: max degree + max importance
    const maxDegree = Math.max(
      ...fabric.nodes.map(n => n.properties.relationCount)
    );
    const maxImportance = Math.max(
      ...fabric.nodes.map(n => n.importance)
    );

    return maxDegree + maxImportance;
  }

  private trackPrivacyBudget(
    fabric: KnowledgeFabric
  ): PrivacyBudget {
    // Track ε consumption across queries
    const queries = this.extractQueries(fabric);

    const total = queries.reduce((sum, q) => sum + q.epsilonUsed, 0);

    return {
      total,
      perQuery: queries.map(q => ({
        queryId: q.id,
        epsilon: q.epsilonUsed,
        timestamp: q.timestamp
      })),
      remaining: Math.max(0, 1.0 - total)
    };
  }
}
```

### 2.3 Cross-Tenant Leak Detection

```typescript
export class CrossTenantLeakDetector {
  /**
   * Detect potential data leakage across tenants
   */
  async detectLeaks(
    fabric: KnowledgeFabric
  ): Promise<LeakDetectionResult> {
    const leaks: DataLeak[] = [];

    // Check 1: Identity inference attack
    const identityLeaks = await this.detectIdentityInference(fabric);
    leaks.push(...identityLeaks);

    // Check 2: Membership inference attack
    const membershipLeaks = await this.detectMembershipInference(fabric);
    leaks.push(...membershipLeaks);

    // Check 3: Attribute inference attack
    const attributeLeaks = await this.detectAttributeInference(fabric);
    leaks.push(...attributeLeaks);

    return {
      passed: leaks.length === 0,
      leaks,
      severity: this.assessSeverity(leaks),
      mitigation: this.generateMitigation(leaks)
    };
  }

  private async detectIdentityInference(
    fabric: KnowledgeFabric
  ): Promise<DataLeak[]> {
    const leaks: DataLeak[] = [];

    // Check if tenantId can be inferred from anonymized data
    fabric.nodes.forEach(node => {
      if (node.tenantId && this.canInferTenant(node, fabric)) {
        leaks.push({
          type: 'identity-inference',
          nodeId: node.id,
          severity: 'high',
          description: 'TenantId can be inferred from quasi-identifiers',
          confidence: 0.9
        });
      }
    });

    return leaks;
  }
}
```

### 2.4 Federated Node 서명 체계

```typescript
export class FederatedSignatureScheme {
  /**
   * Sign knowledge contribution from tenant
   */
  async signContribution(
    tenantId: string,
    nodes: AnonymizedNode[],
    privateKey: crypto.KeyObject
  ): Promise<SignedContribution> {
    // Create contribution hash
    const contributionHash = this.hashContribution(nodes);

    // Sign with tenant's private key
    const signature = crypto.sign(
      'sha256',
      Buffer.from(contributionHash),
      privateKey
    );

    return {
      tenantId,
      nodes,
      contributionHash,
      signature: signature.toString('base64'),
      timestamp: new Date(),
      version: '1.0'
    };
  }

  /**
   * Verify contribution signature
   */
  async verifyContribution(
    contribution: SignedContribution,
    publicKey: crypto.KeyObject
  ): Promise<VerificationResult> {
    // Recompute hash
    const expectedHash = this.hashContribution(contribution.nodes);

    // Verify signature
    const valid = crypto.verify(
      'sha256',
      Buffer.from(expectedHash),
      publicKey,
      Buffer.from(contribution.signature, 'base64')
    );

    return {
      valid,
      tenantId: contribution.tenantId,
      timestamp: contribution.timestamp,
      integrity: expectedHash === contribution.contributionHash
    };
  }
}
```

---

## Axis 3: ⚡ Optimizer Safety Controller

### 3.1 Auto-Rollback 정책

**Threshold**: Δlatency > 10% 또는 error rate > 5%

```typescript
// src/runtime/optimization/safety-controller.ts
export class OptimizerSafetyController {
  /**
   * Monitor optimization impact and trigger rollback if needed
   */
  async monitorAndRollback(
    action: OptimizationAction,
    baseline: PerformanceBaseline
  ): Promise<SafetyResult> {
    // Execute action
    await this.executeAction(action);

    // Wait for stabilization
    await this.wait(60000); // 1 minute

    // Measure current performance
    const current = await this.measurePerformance();

    // Calculate deltas
    const latencyDelta = (current.latency - baseline.latency) / baseline.latency;
    const errorDelta = current.errorRate - baseline.errorRate;

    // Check thresholds
    const shouldRollback =
      latencyDelta > 0.10 || // > 10% latency increase
      errorDelta > 0.05 ||   // > 5% error rate increase
      current.errorRate > 0.01; // > 1% absolute error rate

    if (shouldRollback) {
      await this.rollbackAction(action);

      return {
        status: 'rollback',
        reason: this.formatRollbackReason(latencyDelta, errorDelta),
        baseline,
        current,
        action
      };
    }

    return {
      status: 'success',
      baseline,
      current,
      action
    };
  }
}
```

### 3.2 Bandit Update Cooldown

**Policy**: 24시간 cooldown between updates

```typescript
export class BanditCooldownManager {
  private lastUpdates = new Map<string, Date>();
  private readonly COOLDOWN_MS = 24 * 60 * 60 * 1000; // 24h

  /**
   * Check if bandit can be updated
   */
  canUpdate(operatorId: string): boolean {
    const lastUpdate = this.lastUpdates.get(operatorId);

    if (!lastUpdate) return true;

    const elapsed = Date.now() - lastUpdate.getTime();
    return elapsed >= this.COOLDOWN_MS;
  }

  /**
   * Record update and start cooldown
   */
  recordUpdate(operatorId: string): void {
    this.lastUpdates.set(operatorId, new Date());
  }

  /**
   * Get remaining cooldown time
   */
  getRemainingCooldown(operatorId: string): number {
    const lastUpdate = this.lastUpdates.get(operatorId);

    if (!lastUpdate) return 0;

    const elapsed = Date.now() - lastUpdate.getTime();
    return Math.max(0, this.COOLDOWN_MS - elapsed);
  }
}
```

### 3.3 Risk Level Monitoring

```typescript
export class RiskLevelMonitor {
  /**
   * Monitor optimization risk in real-time
   */
  async monitorRisk(
    action: OptimizationAction,
    window: number = 300000 // 5 minutes
  ): Promise<RiskAssessment> {
    const metrics: RiskMetric[] = [];

    const startTime = Date.now();
    while (Date.now() - startTime < window) {
      // Collect metrics every 10 seconds
      await this.wait(10000);

      const metric = await this.collectMetric();
      metrics.push(metric);

      // Check for anomalies
      const anomaly = this.detectAnomaly(metrics);
      if (anomaly) {
        return {
          risk: 'high',
          anomaly,
          recommendation: 'Immediate rollback',
          metrics
        };
      }
    }

    return {
      risk: this.assessOverallRisk(metrics),
      metrics,
      stable: true
    };
  }

  private detectAnomaly(metrics: RiskMetric[]): Anomaly | null {
    // Check for sudden spikes
    if (metrics.length < 3) return null;

    const recent = metrics.slice(-3);
    const avgLatency = recent.reduce((sum, m) => sum + m.latency, 0) / 3;
    const baseline = metrics.slice(0, -3).reduce((sum, m) => sum + m.latency, 0) / (metrics.length - 3);

    // Spike detection: > 50% increase
    if (avgLatency > baseline * 1.5) {
      return {
        type: 'latency-spike',
        severity: 'high',
        value: avgLatency,
        baseline
      };
    }

    return null;
  }
}
```

---

## Implementation Plan

### Timeline: 3 Weeks

#### Week 1: Validation Foundation
- [ ] Day 1-2: Integration test framework setup
- [ ] Day 3-5: Runtime + Trust tests (180 tests)
- [ ] Day 6-7: Regression gate runner implementation

**Deliverable**: 180 tests + gate automation

#### Week 2: Privacy & Optimizer
- [ ] Day 8-10: Knowledge + Policy tests (120 tests)
- [ ] Day 11-12: Privacy audit system (k-anonymity + ε-DP)
- [ ] Day 13-14: Optimizer safety controller

**Deliverable**: 300 tests + privacy auditor + safety controller

#### Week 3: Chaos & E2E
- [ ] Day 15-16: E2E + Optimizer tests (100 tests)
- [ ] Day 17-18: Chaos simulation (4 types)
- [ ] Day 19-21: Full system validation + KPI dashboard

**Deliverable**: 400+ tests + chaos framework + dashboard

---

## Success Metrics

### Phase 3.6 Exit Criteria

| Metric | Target | Validation |
|--------|--------|------------|
| Integration Tests | ≥ 400 | `npm test` count |
| Test Coverage | ≥ 85% | `npm run test:coverage` |
| k-Anonymity | k ≥ 5 | Privacy audit report |
| ε-DP Budget | ε ≤ 1.0 | DP audit report |
| Optimizer Stability | ≥ 99% | 7-day monitoring |
| Chaos Resilience | ≥ 90% | 4 chaos scenarios pass |
| System Resilience | +40% | Composite score |

### KPI Dashboard

```typescript
// scripts/metrics/phase-3-6-kpi.ts
export interface Phase36KPI {
  testing: {
    totalTests: number;
    coverage: number;
    passRate: number;
    regressionGates: {
      total: number;
      passing: number;
    };
  };
  privacy: {
    kAnonymity: {
      k: number;
      violations: number;
      score: number;
    };
    differentialPrivacy: {
      epsilon: number;
      budget: number;
      score: number;
    };
    leakDetection: {
      leaks: number;
      severity: string;
    };
  };
  optimizer: {
    stability: number;
    rollbacks: number;
    successRate: number;
    avgCooldown: number;
  };
  chaos: {
    scenarios: number;
    passed: number;
    resilience: number;
  };
  overall: {
    resilience: number;
    readiness: number;
  };
}
```

---

## Risk Mitigation

### High-Risk Areas

1. **Test Implementation Velocity**
   - Risk: 400+ tests in 3 weeks is aggressive
   - Mitigation: Parallel test writing, code generation templates
   - Fallback: 300 tests minimum for Phase 3.6 exit

2. **Privacy Audit Complexity**
   - Risk: k-anonymity/ε-DP verification is complex
   - Mitigation: Use proven libraries (Google DP, ARX Data Anonymization)
   - Fallback: Manual audit for Phase 3.6, automated in 3.7

3. **Optimizer Stability**
   - Risk: Safety controller may be too conservative
   - Mitigation: Tunable thresholds, graduated rollout
   - Fallback: Manual optimization approval

---

## Phase 4.0 Readiness

Phase 3.6 Hardening은 Phase 4.0 "AI Civic Governance" 준비 단계:

### Phase 4.0 Preview

```
Phase 4.0: AI Civic Governance Network
├── Knowledge Constitution Protocol
│   └── "지식 헌법" 자동 생성 (explainability-of-origin)
├── Federated Consensus Engine
│   └── BFT 합의 모델 (Byzantine Fault Tolerance)
├── AI-Human Council Interface
│   └── Governance Console (Web UI)
└── Neural Cost & QoS Market
    └── AI 자원 경제 자율화
```

Phase 3.6이 완료되면:
- ✅ 100% 신뢰 운영 보장
- ✅ Privacy-preserving federation 검증
- ✅ Self-optimizing system 안정화
- ✅ Phase 4.0 착수 준비 완료

---

## Appendix

### A. Test Coverage Matrix

| Component | Unit | Integration | E2E | Chaos |
|-----------|------|-------------|-----|-------|
| Runtime L1-L4 | ✅ | 100 tests | 20 | 1 |
| Trust | ✅ | 80 tests | 10 | 0 |
| Knowledge | ✅ | 60 tests | 5 | 1 |
| Policy | ✅ | 60 tests | 5 | 1 |
| Optimizer | ✅ | 60 tests | 0 | 1 |

### B. Privacy Budget Allocation

| Operation | ε Budget | Frequency | Total ε |
|-----------|----------|-----------|---------|
| Knowledge Contribution | 0.1 | 10/day | 1.0/day |
| Cross-tenant Query | 0.05 | 20/day | 1.0/day |
| Validation | 0.01 | 100/day | 1.0/day |

### C. Optimizer Safety Thresholds

| Metric | Baseline | Warning | Critical | Rollback |
|--------|----------|---------|----------|----------|
| Latency Δ | 0% | +5% | +10% | ✅ |
| Error Rate Δ | 0% | +2% | +5% | ✅ |
| Cost Δ | 0% | +10% | +20% | ⚠️ |

---

**Next Steps**:
1. Create integration test framework
2. Implement Privacy Audit system
3. Build Optimizer Safety Controller
4. Deploy Chaos Simulation
5. Launch KPI Dashboard

**Status**: Ready for implementation ✅
